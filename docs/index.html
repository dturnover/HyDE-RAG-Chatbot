<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8"/>
    <title>Fight Chaplain LLM Demo</title>
    <meta name="viewport" content="width=device-width,initial-scale=1"/>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        #log::-webkit-scrollbar { width: 8px; }
        #log::-webkit-scrollbar-thumb { background-color: #cbd5e1; border-radius: 10px; }
        #log::-webkit-scrollbar-track { background-color: #f1f5f9; }
    </style>
    <script>
        tailwind.config = { /* ... config ... */ }
    </script>
</head>
<body class="bg-bg-light min-h-screen p-4 sm:p-6 font-sans">
    <div class="max-w-3xl mx-auto bg-white shadow-xl rounded-2xl p-6 md:p-8">
        <h2 class="text-3xl font-bold text-gray-800 mb-6 border-b pb-2">
            Fight Chaplain Demo
        </h2>
        <div class="flex flex-wrap items-center gap-3 mb-6">
            <button id="health" class="px-4 py-2 bg-indigo-600 text-white font-medium rounded-lg hover:bg-indigo-700 transition duration-150 shadow-md">
                Check Backend
            </button>
            <label class="text-sm text-secondary-gray flex items-center gap-1">
                <input type="checkbox" id="stream" checked class="form-checkbox rounded text-primary-green">
                Stream Response (SSE)
            </label>
            <button id="clear" class="px-4 py-2 bg-red-500 text-white font-medium rounded-lg hover:bg-red-600 transition duration-150 shadow-md">
                Clear Log
            </button>
        </div>
        <div id="log" class="border border-gray-300 bg-white rounded-xl p-4 md:p-5 min-h-80 max-h-[60vh] overflow-y-auto mb-6 shadow-inner text-sm">
            <div class="text-gray-500 italic">Start by clicking 'Check Backend' or sending a message.</div>
        </div>
        <div class="flex gap-4 items-end">
            <textarea id="msg" rows="3" placeholder="Type your message... (e.g., I'm feeling stressed. Can you find me a verse from the Bible?)"
                      class="flex-grow w-full p-3 border border-gray-300 rounded-lg focus:ring-primary-green focus:border-primary-green transition duration-150 resize-none text-gray-700"></textarea>
            <button id="send" class="h-14 w-20 bg-primary-green text-white font-semibold rounded-lg hover:bg-green-700 transition duration-150 shadow-lg flex items-center justify-center">
                Send
            </button>
        </div>
    </div>

<script>
    const API = "https://llm-api-demo-5qz1.onrender.com";

    const log = document.getElementById("log");
    const msgEl = document.getElementById("msg");
    const healthBtn = document.getElementById("health");
    const clearBtn = document.getElementById("clear");
    const sendBtn = document.getElementById("send");
    const streamBox = document.getElementById("stream");

    // ★★★ FIX 1: Add the Session ID helper function back ★★★
    const getSID = () => {
        let sid = localStorage.getItem("sid");
        if (!sid) {
            sid = crypto.randomUUID ? crypto.randomUUID() : Math.random().toString(36).slice(2);
            localStorage.setItem("sid", sid);
        }
        return sid;
    };

    const addLine = (cls, role, text = "") => { /* ... function is unchanged ... */ };
    const addDbg = (t) => { /* ... function is unchanged ... */ };
    healthBtn.onclick = async () => { /* ... function is unchanged ... */ };
    clearBtn.onclick = () => { log.textContent = ""; };

    sendBtn.onclick = async () => {
        const text = (msgEl.value || "").trim();
        if (!text) return;
        addLine("you", "You", text);
        msgEl.value = "";

        const payload = {
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                // ★★★ FIX 2: Add the Session ID to every request ★★★
                "X-Session-Id": getSID()
            },
            body: JSON.stringify({ message: text }),
        };

        const useStream = !!streamBox.checked;
        if (!useStream) {
            // This non-streaming branch now also sends the SID correctly
            try {
                const r = await fetch(`${API}/chat`, payload);
                const j = await r.json();
                const responseText = j?.text ?? "[No response or response key mismatch]";
                addLine("bot", "Bot", responseText);
                if (j?.footer) addDbg(j.footer);
            } catch (e) {
                addLine("bot", "Bot", "[Network Error] " + (e?.message || e));
            }
            return;
        }

        // The streaming branch also sends the SID correctly
        try {
            const response = await fetch(`${API}/chat`, payload);
            if (!response.body) throw new Error("Response body is missing.");
            
            const reader = response.body.getReader();
            const decoder = new TextDecoder();
            let buffer = "";

            const { line, msgSpan } = addLine("bot", "Bot", "");
            const cursor = document.createElement("span");
            cursor.className = "cursor inline-block w-1.5 h-4 bg-gray-500 align-middle ml-0.5 animate-pulse rounded-sm";
            line.appendChild(cursor);

            let fullText = "";

            while (true) {
                const { done, value } = await reader.read();
                if (done) break;

                buffer += decoder.decode(value, { stream: true });
                const lines = buffer.split("\n\n");
                buffer = lines.pop(); // Keep the last, possibly incomplete line

                for (const line of lines) {
                    if (line.startsWith("data: ")) {
                        const data = line.substring(6).trim();
                        if (data === "[END]") continue;
                        try {
                            const obj = JSON.parse(data);
                            if (obj.text) {
                                fullText += obj.text;
                                msgSpan.textContent = fullText;
                            }
                            if (obj.footer) {
                                fullText += obj.footer;
                                msgSpan.textContent = fullText;
                            }
                        } catch(e) { /* Ignore non-json data chunks */ }
                    }
                }
                log.scrollTop = log.scrollHeight;
            }
            cursor.remove();
        } catch (e) {
            addLine("bot", "Bot", "[Stream Error] " + (e?.message || e));
        }
    };
    
    // Helper functions need to be defined before they are used
    (function() {
        const originalAddLine = addLine;
        window.addLine = function(cls, role, text = "") {
            const lineData = originalAddLine(cls, role, text);
            if (lineData.line.parentElement) {
                lineData.line.parentElement.scrollTop = lineData.line.parentElement.scrollHeight;
            }
            return lineData;
        };

        const originalAddDbg = addDbg;
        window.addDbg = function(t) {
            originalAddDbg(t);
            log.scrollTop = log.scrollHeight;
        };

        healthBtn.onclick = async () => {
            try {
                const r = await fetch(`${API}/diag`);
                const json = await r.json();
                addDbg(`Backend Status: OK | Model: ${json.openai_model}`);
            } catch (e) {
                addDbg(`Backend Error: ${e?.message||e}. Ensure Render service is running at ${API}`);
            }
        };

        clearBtn.onclick = () => { log.innerHTML = ""; };
        msgEl.addEventListener("keydown", (e) => { if (e.key === "Enter" && (e.metaKey || e.ctrlKey)) sendBtn.onclick(); });

        (async () => { try { await fetch(`${API}/diag`); } catch {} })();
    })();

</script>
</body>
</html>